import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["focusableOnFocus", "focusableOnBlur"],
    _excluded2 = ["children", "prefixIcon", "suffixIcon", "onClick", "dataHook", "className"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import React from 'react';
import PropTypes from 'prop-types';
import { withFocusable } from "wix-ui-core/dist/es/src/hocs/Focusable";
import { generateDataAttr } from '../utils/generateDataAttr';
import { SKIN, TYPE, SIZE } from './constants';
import { st, classes } from './Badge.st.css';
import Caption from '../Text/Caption';

var Badge = /*#__PURE__*/function (_React$PureComponent) {
  _inherits(Badge, _React$PureComponent);

  var _super = _createSuper(Badge);

  function Badge() {
    var _this;

    _classCallCheck(this, Badge);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "getProps", function () {
      // that's what you pay for using HOCs...
      var _this$props = _this.props,
          focusableOnFocus = _this$props.focusableOnFocus,
          focusableOnBlur = _this$props.focusableOnBlur,
          rest = _objectWithoutProperties(_this$props, _excluded);

      return rest;
    });

    _defineProperty(_assertThisInitialized(_this), "_getFocusableProps", function () {
      // add focusable hooks only when badge is clickable
      var _this$props2 = _this.props,
          onClick = _this$props2.onClick,
          focusableOnFocus = _this$props2.focusableOnFocus,
          focusableOnBlur = _this$props2.focusableOnBlur;
      return onClick ? {
        onFocus: focusableOnFocus,
        onBlur: focusableOnBlur,
        tabIndex: 0
      } : {};
    });

    return _this;
  }

  _createClass(Badge, [{
    key: "render",
    value: function render() {
      var _this$getProps = this.getProps(),
          children = _this$getProps.children,
          prefixIcon = _this$getProps.prefixIcon,
          suffixIcon = _this$getProps.suffixIcon,
          onClick = _this$getProps.onClick,
          dataHook = _this$getProps.dataHook,
          className = _this$getProps.className,
          rest = _objectWithoutProperties(_this$getProps, _excluded2);

      return /*#__PURE__*/React.createElement("div", _extends({
        "data-hook": dataHook,
        onClick: onClick
      }, this._getFocusableProps(), {
        className: st(classes.root, _objectSpread({
          clickable: !!onClick
        }, rest), className)
      }, generateDataAttr(this.props, ['type', 'skin', 'size', 'uppercase']), {
        "data-clickable": !!onClick
        /* TODO: this prop used to come from stylable v1 spread and is used for testing. Update component testkit to use stylable testkit instead */
        ,
        "data-is-inverted": rest['data-is-inverted']
      }), prefixIcon && /*#__PURE__*/React.cloneElement(prefixIcon, {
        className: classes.prefix,
        'data-prefix-icon': true
      }), /*#__PURE__*/React.createElement(Caption, {
        className: classes.text,
        caption: this.getProps().size === 'tiny' ? 'c2' : 'c1',
        ellipsis: true
      }, children), suffixIcon && /*#__PURE__*/React.cloneElement(suffixIcon, {
        className: classes.suffix,
        'data-suffix-icon': true
      }));
    }
  }]);

  return Badge;
}(React.PureComponent);

_defineProperty(Badge, "propTypes", {
  /** Applied as data-hook HTML attribute that can be used to create driver in testing */
  dataHook: PropTypes.string,

  /** A css class to be applied to the component's root element */
  className: PropTypes.string,

  /** variation of the component structure */
  type: PropTypes.oneOf(['solid', 'outlined', 'transparent']),

  /** color indication of the component */
  skin: PropTypes.oneOf(['general', 'standard', 'danger', 'success', 'neutral', 'warning', 'urgent', 'neutralLight', 'neutralStandard', 'neutralSuccess', 'neutralDanger', 'premium', 'warningLight']),

  /** component size */
  size: PropTypes.oneOf(['medium', 'small', 'tiny']),

  /** usually an icon to appear at the beginning of the text */
  prefixIcon: PropTypes.node,

  /** usually an icon to appear at the end of the text */
  suffixIcon: PropTypes.node,

  /** callback function called when badge is clicked */
  onClick: PropTypes.func,

  /** forces an uppercase letters */
  uppercase: PropTypes.bool,
  focusableOnFocus: PropTypes.func,
  focusableOnBlur: PropTypes.func,

  /** the text to display in the badge */
  children: PropTypes.node
});

_defineProperty(Badge, "displayName", 'Badge');

_defineProperty(Badge, "defaultProps", {
  type: TYPE.solid,
  skin: SKIN.general,
  size: SIZE.medium,
  uppercase: true
});

export default withFocusable(Badge);