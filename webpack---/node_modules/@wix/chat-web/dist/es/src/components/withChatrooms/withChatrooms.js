import { __assign, __extends, __rest } from "tslib";
import React from 'react';
import { chatSdk, } from '@wix/chat-sdk';
import Waypoint from 'react-waypoint';
import style from './withChatrooms.scss';
import classNames from 'classnames';
import { Loader } from 'wix-style-react';
import _debounce from 'lodash/debounce';
export var ON_CHANGE_DEBOUNCE_TIME = 100;
export var withChatrooms = function (ComponentToWrap) {
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.state = {
                chatrooms: [],
                isFirstLoading: true,
                isFetchingChatrooms: true,
                cursor: undefined,
                hasError: false,
                error: null,
            };
            _this.handleOnEnterLastChatroom = function () {
                if (_this.state.chatrooms && _this.state.cursor) {
                    _this.fetchMore(_this.state.cursor);
                }
            };
            _this.onChatroomsListChange = function (_a) {
                var rooms = _a.rooms, _b = _a.status, _c = (_b === void 0 ? {} : _b).isFetchingRooms, isFetchingRooms = _c === void 0 ? true : _c, cursor = _a.cursor;
                var isFirstLoading = (!rooms || rooms.length === 0) && isFetchingRooms;
                _this.setState({
                    chatrooms: rooms,
                    isFetchingChatrooms: isFetchingRooms,
                    cursor: cursor,
                    isFirstLoading: isFirstLoading,
                });
            };
            _this.getOnChangeCallback = function () {
                var _a;
                var shouldDebounceOnChange = (_a = _this.props.labelsIdsToFilterBy) === null || _a === void 0 ? void 0 : _a.length;
                return shouldDebounceOnChange
                    ? _debounce(_this.onChatroomsListChange, ON_CHANGE_DEBOUNCE_TIME)
                    : _this.onChatroomsListChange;
            };
            return _this;
        }
        class_1.prototype.componentDidMount = function () {
            try {
                this.setState({ hasError: false, error: null });
                var subscription = chatSdk.subscribeToChatRoomsList({
                    callback: this.getOnChangeCallback(),
                    filter: {
                        isArchived: !!this.props.isArchived,
                        isUnread: !!this.props.isUnread,
                        participantIds: this.props.participantIds,
                        participantType: this.props.participantType,
                        labelIds: this.props.labelsIdsToFilterBy,
                    },
                });
                this.unsubscribe = subscription.unsubscribe;
                this.fetchMore = subscription.fetchMore;
            }
            catch (e) {
                this.setState({ hasError: true, error: e });
            }
        };
        class_1.prototype.componentWillUnmount = function () {
            this.unsubscribe && this.unsubscribe();
        };
        class_1.prototype.render = function () {
            var _a;
            var _b = this.state, chatrooms = _b.chatrooms, isFetchingChatrooms = _b.isFetchingChatrooms, isFirstLoading = _b.isFirstLoading, hasError = _b.hasError;
            var _c = this.props, _d = _c.scrollable, isScrollable = _d === void 0 ? true : _d, isArchived = _c.isArchived, usedProps = __rest(_c, ["scrollable", "isArchived"]);
            return (React.createElement("div", { className: classNames((_a = {},
                    _a[style.scrollable] = isScrollable,
                    _a)), "data-hook": "with-chatrooms-wrapper" },
                React.createElement(ComponentToWrap, __assign({}, usedProps, { chatrooms: chatrooms, isFirstLoading: isFirstLoading, isFetchingChatrooms: isFetchingChatrooms, hasError: hasError })),
                React.createElement(Waypoint, { key: "fetch-more-chatrooms-waypoint", onEnter: this.handleOnEnterLastChatroom }),
                isFetchingChatrooms && !hasError && (React.createElement("div", { "data-hook": "fetch-more-chatrooms-loader", className: style.loader },
                    React.createElement(Loader, { dataHook: "loader", size: "small" })))));
        };
        return class_1;
    }(React.Component));
};
//# sourceMappingURL=withChatrooms.js.map