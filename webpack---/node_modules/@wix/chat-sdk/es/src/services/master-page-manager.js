import { __awaiter, __generator } from "tslib";
import objectHash from 'object-hash';
import { FetchMasterPagePageSize } from '../constants/constants';
var endOfListResponse = { masterPage: [], cursor: null };
var MasterPageState = /** @class */ (function () {
    function MasterPageState() {
        this.state = {};
        this.hashFilter = function (filter) { return objectHash(filter, { unorderedArrays: true }); };
        this.state = {};
    }
    MasterPageState.prototype.get = function (filter) {
        var _a;
        var hash = this.hashFilter(filter);
        return (_a = this.state[hash]) !== null && _a !== void 0 ? _a : null;
    };
    MasterPageState.prototype.set = function (filter, masterPage) {
        var hash = this.hashFilter(filter);
        this.state[hash] = masterPage;
        return this;
    };
    MasterPageState.prototype.clear = function () {
        this.state = {};
    };
    MasterPageState.prototype.has = function (filter) {
        var hash = this.hashFilter(filter);
        return !!this.state[hash];
    };
    MasterPageState.prototype.delete = function (filter) {
        if (this.has(filter)) {
            var hash = this.hashFilter(filter);
            delete this.state[hash];
            return true;
        }
        else {
            return false;
        }
    };
    // We can probably ditch the map implementation and delete from here...
    MasterPageState.prototype.entries = function () {
        return Object.entries(this.state)[Symbol.iterator]();
    };
    MasterPageState.prototype.keys = function () {
        return Object.keys(this.state)[Symbol.iterator]();
    };
    MasterPageState.prototype.values = function () {
        return Object.values(this.state)[Symbol.iterator]();
    };
    Object.defineProperty(MasterPageState.prototype, "size", {
        get: function () {
            return Object.keys(this.state).length;
        },
        enumerable: false,
        configurable: true
    });
    MasterPageState.prototype[Symbol.iterator] = function () {
        return this.entries();
    };
    MasterPageState.prototype.forEach = function (callback) {
        var _this = this;
        Object.entries(this.state).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            return callback(value, key, _this);
        });
    };
    Object.defineProperty(MasterPageState.prototype, Symbol.toStringTag, {
        get: function () {
            return JSON.stringify(this.state);
        },
        enumerable: false,
        configurable: true
    });
    return MasterPageState;
}());
var MasterPageManager = /** @class */ (function () {
    function MasterPageManager() {
    }
    MasterPageManager.setServerApi = function (repository) {
        this.repository = repository;
    };
    MasterPageManager.getMasterPage = function (filter) {
        return __awaiter(this, void 0, void 0, function () {
            var masterPage;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!this.masterPageState.has(filter)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.repository.http$fetchMasterPage({ filter: filter })];
                    case 1:
                        masterPage = _a.sent();
                        this.setMasterPage(filter, masterPage);
                        return [2 /*return*/, masterPage];
                    case 2: return [2 /*return*/, this.masterPageState.get(filter)];
                }
            });
        });
    };
    MasterPageManager.setMasterPage = function (filter, masterPage) {
        // IMPORTANT: We get them sorted by the server, otherwise uncomment this line
        // masterPage =  masterPage.sort((a, b) => b.sortRank - a.sortRank);
        this.masterPageState.set(filter, masterPage);
    };
    MasterPageManager.deleteMasterPage = function (filter) {
        return this.masterPageState.delete(filter);
    };
    /***
     * When we receive a RT event notifiying of a deleted room,
     * we need to remove it from the master page so we don't
     * accidentally fetch it
     */
    MasterPageManager.removeRoom = function (id) {
        this.masterPageState.forEach(function (masterPage) {
            masterPage.splice(masterPage.findIndex(function (entry) { return entry.id === id; }), 1);
        });
    };
    MasterPageManager.clearAllMasterPages = function () {
        this.masterPageState.clear();
    };
    MasterPageManager.getPage = function (_a) {
        var _b = _a.filter, filter = _b === void 0 ? {} : _b, pointer = _a.pointer, _c = _a.pageSize, pageSize = _c === void 0 ? FetchMasterPagePageSize : _c;
        return __awaiter(this, void 0, void 0, function () {
            var masterPage, firstRoomAfterCursorIndex, noRoomsAfterCursor, roomsAfterCursor, pageContainsEndOfMasterPage, cursor, lastRoom;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, this.getMasterPage(filter)];
                    case 1:
                        masterPage = _d.sent();
                        if (masterPage.length === 0) {
                            return [2 /*return*/, endOfListResponse];
                        }
                        firstRoomAfterCursorIndex = pointer ? masterPage.findIndex(function (mpe) { return mpe.sortRank < pointer; }) : 0;
                        noRoomsAfterCursor = firstRoomAfterCursorIndex < 0;
                        if (noRoomsAfterCursor) {
                            return [2 /*return*/, endOfListResponse];
                        }
                        roomsAfterCursor = masterPage.slice(firstRoomAfterCursorIndex, firstRoomAfterCursorIndex + pageSize);
                        pageContainsEndOfMasterPage = roomsAfterCursor.length < pageSize;
                        if (pageContainsEndOfMasterPage) {
                            cursor = null;
                        }
                        else {
                            lastRoom = roomsAfterCursor[roomsAfterCursor.length - 1];
                            cursor = lastRoom.sortRank;
                        }
                        return [2 /*return*/, { masterPage: roomsAfterCursor, cursor: cursor }];
                }
            });
        });
    };
    MasterPageManager.masterPageState = new MasterPageState();
    return MasterPageManager;
}());
export default MasterPageManager;
