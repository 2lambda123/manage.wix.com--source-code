"use strict";

exports.__esModule = true;
exports["default"] = void 0;

var _react = _interopRequireDefault(require("react"));

var _CSSTransition = _interopRequireDefault(require("react-transition-group/CSSTransition"));

var _constants = require("../constants/constants");

var _timeClass = require("../class/time-class");

var _AnimatorChild = _interopRequireDefault(require("./AnimatorChild"));

var _shouldFlipAnimation = _interopRequireDefault(require("../helpers/should-flip-animation"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var CSSTransitionWrapper = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(CSSTransitionWrapper, _React$Component);

  function CSSTransitionWrapper(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.transitionDefault = void 0;
    _this.transitionDefault = {
      enter: false,
      entering: false,
      exit: false,
      exiting: false
    };
    _this.state = {
      sequenceIndex: 0,
      transition: _this.transitionDefault
    };
    return _this;
  } // eslint-disable-next-line camelcase


  var _proto = CSSTransitionWrapper.prototype;

  _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
    var debug = props.animatorProps.debug;

    if (debug) {
      this.setDebug(debug);
    }
  };

  _proto.setDebug = function setDebug(debug) {
    if (debug === 'enter') {
      this.onEnter();
    } else if (debug === 'entering') {
      this.onEntering();
    } else if (debug === 'entered') {
      this.onEntered();
    } else if (debug === 'exit') {
      this.onExit();
    } else if (debug === 'exiting') {
      this.onExiting();
    } else if (debug === 'exited') {
      this.onExited();
    }
  };

  _proto.updateTransitionState = function updateTransitionState(phase) {
    var update;

    switch (phase) {
      case 'enter':
        update = {
          enter: true
        };
        break;

      case 'entering':
        update = {
          enter: true,
          entering: true
        };
        break;

      case 'exit':
        update = {
          exit: true
        };
        break;

      case 'exiting':
        update = {
          exit: true,
          exiting: true
        };
        break;

      default:
        update = {};
        break;
    }

    this.setState({
      transition: Object.assign({}, this.transitionDefault, update)
    });
  };

  _proto.onEnter = function onEnter() {
    var onAnimationEnter = this.props.onAnimationEnter;
    this.updateTransitionState('enter');
    this.setSequenceIndex();
    onAnimationEnter && onAnimationEnter();
  };

  _proto.onEntering = function onEntering() {
    var onAnimationEntering = this.props.onAnimationEntering;
    this.updateTransitionState('entering');
    onAnimationEntering && onAnimationEntering();
  };

  _proto.onEntered = function onEntered() {
    var onAnimationEntered = this.props.onAnimationEntered;
    this.updateTransitionState('entered');
    onAnimationEntered && onAnimationEntered();
  };

  _proto.onExit = function onExit() {
    var onAnimationExit = this.props.onAnimationExit;
    this.updateTransitionState('exit');
    this.setSequenceIndex();
    onAnimationExit && onAnimationExit();
  };

  _proto.onExiting = function onExiting() {
    var onAnimationExiting = this.props.onAnimationExiting;
    this.updateTransitionState('exiting');
    onAnimationExiting && onAnimationExiting();
  };

  _proto.onExited = function onExited() {
    var onAnimationExited = this.props.onAnimationExited;
    this.updateTransitionState('exited');
    onAnimationExited && onAnimationExited();
  };

  _proto.getTransitionProps = function getTransitionProps() {
    var _this$props = this.props,
        animatorProps = _this$props.animatorProps,
        skipMountTransition = _this$props.skipMountTransition,
        inProp = _this$props["in"];
    var transition = this.state.transition;
    var duration = new _timeClass.Time(animatorProps, transition).getTotalDuration();
    var showByProp = {
      // False if `show` is manually set to false, otherwise determined by TransitionGroup transition state
      "in": animatorProps.show === false ? false : inProp
    };
    return _objectSpread({
      enter: !!duration,
      exit: !!duration,
      appear: !skipMountTransition && !!duration,
      timeout: duration,
      classNames: _constants.transitionClassNames,
      mountOnEnter: true,
      unmountOnExit: true
    }, showByProp);
  };

  _proto.setSequenceIndex = function setSequenceIndex() {
    var _this$props$animatorP = this.props.animatorProps,
        children = _this$props$animatorP.children,
        sequence = _this$props$animatorP.sequence;

    if (sequence) {
      var index = this.props.index + 1;
      var reverseIndex = children.length - this.props.index;
      this.setState({
        sequenceIndex: (0, _shouldFlipAnimation["default"])(sequence, this.state.transition) ? reverseIndex : index
      });
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props2 = this.props,
        children = _this$props2.children,
        animatorProps = _this$props2.animatorProps;
    var sequenceIndex = this.state.sequenceIndex;
    return /*#__PURE__*/_react["default"].createElement(_CSSTransition["default"], _extends({}, this.props, this.getTransitionProps(), {
      onEnter: function onEnter() {
        return _this2.onEnter();
      },
      onEntering: function onEntering() {
        return _this2.onEntering();
      },
      onEntered: function onEntered() {
        return _this2.onEntered();
      },
      onExit: function onExit() {
        return _this2.onExit();
      },
      onExiting: function onExiting() {
        return _this2.onExiting();
      },
      onExited: function onExited() {
        return _this2.onExited();
      }
    }), /*#__PURE__*/_react["default"].createElement(_AnimatorChild["default"], {
      transition: this.state.transition,
      sequenceIndex: sequenceIndex,
      animatorProps: animatorProps
    }, children));
  };

  return CSSTransitionWrapper;
}(_react["default"].Component);

var _default = CSSTransitionWrapper;
exports["default"] = _default;