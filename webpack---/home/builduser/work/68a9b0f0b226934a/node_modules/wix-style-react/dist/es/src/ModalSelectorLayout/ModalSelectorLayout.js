import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import React from 'react';
import PropTypes from 'prop-types';
import SelectorList from '../SelectorList';
import HeaderLayout from '../MessageBox/FunctionalLayout/HeaderLayout';
import FooterLayout from '../MessageBox/FunctionalLayout/FooterLayout';
import { classes } from './ModalSelectorLayout.st.css';
import deprecationLog from '../utils/deprecationLog';
import { dataHooks } from './ModalSelectorLayout.helpers';
/**
 * Use this component when needed to select one / multiple items having complex descriptions.
 * E.g.: choosing products to promote via ShoutOuts
 */

var ModalSelectorLayout = /*#__PURE__*/function (_React$PureComponent) {
  _inherits(ModalSelectorLayout, _React$PureComponent);

  var _super = _createSuper(ModalSelectorLayout);

  function ModalSelectorLayout() {
    var _this;

    _classCallCheck(this, ModalSelectorLayout);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "_getEnabledItems", function (items) {
      return items.filter(function (_ref) {
        var disabled = _ref.disabled;
        return !disabled;
      });
    });

    return _this;
  }

  _createClass(ModalSelectorLayout, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      deprecationLog("Using \"<ModalSelectorLayout/>\" is deprecated. Instead, we advise you to use the newer \"<SelectorList/>\" component in combination with \"<CustomModalLayout/>\". Please refer to it's documentation for an example.");
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          dataSource = _this$props.dataSource,
          imageSize = _this$props.imageSize,
          imageShape = _this$props.imageShape,
          searchPlaceholder = _this$props.searchPlaceholder,
          emptyState = _this$props.emptyState,
          renderNoResults = _this$props.noResultsFoundStateFactory,
          itemsPerPage = _this$props.itemsPerPage,
          withSearch = _this$props.withSearch,
          searchDebounceMs = _this$props.searchDebounceMs,
          onSelect = _this$props.onSelect,
          multiple = _this$props.multiple,
          subtitle = _this$props.subtitle,
          dataHook = _this$props.dataHook,
          title = _this$props.title,
          onClose = _this$props.onClose,
          onCancel = _this$props.onCancel,
          _onOk = _this$props.onOk,
          height = _this$props.height,
          maxHeight = _this$props.maxHeight,
          cancelButtonText = _this$props.cancelButtonText,
          okButtonText = _this$props.okButtonText,
          disableConfirmation = _this$props.disableConfirmation,
          sideActions = _this$props.sideActions;
      return /*#__PURE__*/React.createElement(SelectorList, {
        dataSource: dataSource,
        imageSize: imageSize,
        imageShape: imageShape,
        searchPlaceholder: searchPlaceholder,
        emptyState: emptyState,
        renderNoResults: renderNoResults,
        itemsPerPage: itemsPerPage,
        withSearch: withSearch,
        searchDebounceMs: searchDebounceMs,
        onSelect: onSelect,
        multiple: multiple,
        subtitle: subtitle,
        dataHook: dataHooks.selectorList
      }, function (_ref2) {
        var renderList = _ref2.renderList,
            renderToggleAllCheckbox = _ref2.renderToggleAllCheckbox,
            selectedItems = _ref2.selectedItems;

        var enabledItems = _this2._getEnabledItems(selectedItems);

        return /*#__PURE__*/React.createElement("div", {
          "data-hook": dataHook,
          className: classes.modalContent,
          style: {
            height: height,
            maxHeight: maxHeight
          }
        }, /*#__PURE__*/React.createElement(HeaderLayout, {
          title: title,
          onCancel: onClose
        }), renderList(), /*#__PURE__*/React.createElement(FooterLayout, {
          onCancel: onCancel,
          onOk: function onOk() {
            return _onOk(multiple ? enabledItems : enabledItems[0]);
          },
          cancelText: cancelButtonText,
          confirmText: okButtonText,
          enableOk: !disableConfirmation && !!selectedItems.length,
          children: !sideActions && multiple && renderToggleAllCheckbox(),
          sideActions: sideActions
        }));
      });
    }
  }]);

  return ModalSelectorLayout;
}(React.PureComponent);

_defineProperty(ModalSelectorLayout, "displayName", 'ModalSelectorLayout');

_defineProperty(ModalSelectorLayout, "propTypes", {
  /** applied as data-hook HTML attribute that can be used to create driver in testing */
  dataHook: PropTypes.string,

  /** Title of the modal */
  title: PropTypes.node,

  /** Fixed text displayed above the list */
  subtitle: PropTypes.node,

  /** OK button callback, called with the currently selected item  */
  onOk: PropTypes.func,

  /** X button callback */
  onClose: PropTypes.func,

  /** Cancel button callback */
  onCancel: PropTypes.func,

  /**
   * paging function that should have a signature of
   * ```typescript
   * (searchQuery: string, offset: number, limit: number) =>
   * Promise<{
   *  items: Array<{
   *    id: number | string,
   *    title: node,
   *    subtitle?: string,
   *    extraText?: string,
   *    extraNode?: node,
   *    disabled?: boolean // show item as disabled, dont count it in "select all", exclude from `onOk`
   *    selected?: boolean // force item as selected
   *    image?: node
   *    subtitleNode?: node,
   *    belowNode?: node,
   *    showBelowNodeOnSelect?: boolean,
   *  }>,
   *  totalCount: number
   * }>
   * ```
   * `offset` - next requested item's index<br>
   * `limit` - number of items requested<br>
   * `totalCount` - total number of items that suffice the current search query
   * */
  dataSource: PropTypes.func.isRequired,

  /** Cancel button's text */
  cancelButtonText: PropTypes.string,

  /** OK button's text */
  okButtonText: PropTypes.string,

  /** Image icon size */
  imageSize: PropTypes.oneOf(['tiny', 'small', 'portrait', 'large', 'cinema']),

  /**
   * Image icon shape, `rectangular` or `circle`.<br>
   * NOTE: `circle` is not compatible with `imageSize` of `portrait` or `cinema`
   * */
  imageShape: function imageShape(props, propName, componentName) {
    if (['portrait', 'cinema'].includes(props.imageSize) && props[propName] === 'circle') {
      return new Error("".concat(componentName, ": prop \"imageSize\" with value of \"").concat(props.imageSize, "\" is incompatible with prop imageShape with value of \"circle\" \u2014 use \"rectangular\" instead."));
    }
  },

  /** Placeholder text of the search input */
  searchPlaceholder: PropTypes.string,

  /**
   * Component/element that will be rendered when there is nothing to display,
   * i.e. empty `{items:[], totalCount: 0}` was returned on the first call to `dataSource`
   * */
  emptyState: PropTypes.node,

  /**
   * Function that will get the current `searchQuery` and should return the component/element
   * that will be rendered when there are no items that suffice the entered search query
   *  */
  noResultsFoundStateFactory: PropTypes.func,

  /** Number of items loaded each time the user scrolls down */
  itemsPerPage: PropTypes.number,

  /** Whether to display the search input or not */
  withSearch: PropTypes.bool,

  /** Search debounce in milliseconds */
  searchDebounceMs: PropTypes.number,

  /** Height CSS property, sets the height of the modal */
  height: PropTypes.string,

  /** Max-height CSS property, sets the maximum height of the modal. */
  maxHeight: PropTypes.string,

  /** display checkbox and allow multi selection */
  multiple: PropTypes.bool,

  /** string to be displayed in footer when `multiple` prop is used and no items are selected  */
  selectAllText: PropTypes.string,

  /** string to be displayed in footer when `multiple` prop is used and some or all items ar selected */
  deselectAllText: PropTypes.string,

  /** to disable confirm button */
  disableConfirmation: PropTypes.bool,

  /** callback that triggers on select and return selected item object*/
  onSelect: PropTypes.func,

  /** Used to display some side component in the footer.
   * Will override element select all in the footer when multiple=true */
  sideActions: PropTypes.node
});

_defineProperty(ModalSelectorLayout, "defaultProps", {
  title: 'Choose Your Items',
  okButtonText: 'Select',
  cancelButtonText: 'Cancel',
  searchPlaceholder: 'Search...',
  imageSize: 'large',
  imageShape: 'rectangular',
  itemsPerPage: 50,
  withSearch: true,
  height: '100%',
  maxHeight: '100%',
  selectAllText: 'Select All',
  deselectAllText: 'Deselect All',
  disableConfirmation: false
});

export { ModalSelectorLayout as default };