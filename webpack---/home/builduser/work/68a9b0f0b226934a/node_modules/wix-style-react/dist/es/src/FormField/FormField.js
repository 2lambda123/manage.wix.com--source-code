import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _extends from "@babel/runtime/helpers/extends";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import PropTypes from 'prop-types';
import React from 'react';
import InfoIcon from '../InfoIcon';
import Text, { SIZES, SKINS, WEIGHTS } from '../Text';
import { dataHooks } from './constants';
import { st, classes } from './FormField.st.css';
import { TooltipCommonProps } from '../common/PropTypes/TooltipCommon';
import { WixStyleReactContext } from '../WixStyleReactProvider/context';
var PLACEMENT = {
  top: 'top',
  right: 'right',
  left: 'left'
};
var ALIGN = {
  middle: 'middle',
  top: 'top'
};
var asterisk = /*#__PURE__*/React.createElement("div", {
  "data-hook": dataHooks.asterisk,
  className: classes.asterisk,
  children: "*"
});

var charactersLeft = function charactersLeft(lengthLeft) {
  var colorProps = lengthLeft >= 0 ? {
    light: true,
    secondary: true
  } : {
    skin: SKINS.error
  };
  return /*#__PURE__*/React.createElement(Text, _extends({
    size: SIZES.small,
    weight: WEIGHTS.normal
  }, colorProps, {
    dataHook: dataHooks.counter,
    children: lengthLeft
  }));
};

var FormField = /*#__PURE__*/function (_React$Component) {
  _inherits(FormField, _React$Component);

  var _super = _createSuper(FormField);

  function FormField() {
    var _this;

    _classCallCheck(this, FormField);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "state", {
      lengthLeft: undefined
    });

    _defineProperty(_assertThisInitialized(_this), "childrenRenderPropInterface", {
      setCharactersLeft: function setCharactersLeft(lengthLeft) {
        return _this.setState({
          lengthLeft: lengthLeft
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_hasCharCounter", function () {
      return _this.props.charCount !== undefined || typeof _this.state.lengthLeft === 'number';
    });

    _defineProperty(_assertThisInitialized(_this), "_renderCharCounter", function () {
      if (!_this._hasCharCounter()) {
        return;
      }

      var charCount = _this.props.charCount;
      return charactersLeft(charCount !== undefined ? charCount : _this.state.lengthLeft);
    });

    _defineProperty(_assertThisInitialized(_this), "_renderInfoIcon", function (_ref) {
      var labelSize = _ref.labelSize;
      var _this$props = _this.props,
          infoContent = _this$props.infoContent,
          infoTooltipProps = _this$props.infoTooltipProps;
      return infoContent && /*#__PURE__*/React.createElement(InfoIcon, {
        dataHook: dataHooks.infoIcon,
        className: classes.infoIcon,
        content: infoContent,
        tooltipProps: infoTooltipProps,
        size: labelSize
      });
    });

    _defineProperty(_assertThisInitialized(_this), "_renderLabelIndicators", function (_ref2) {
      var labelSize = _ref2.labelSize;
      var _this$props2 = _this.props,
          required = _this$props2.required,
          suffix = _this$props2.suffix;
      return /*#__PURE__*/React.createElement("div", {
        "data-hook": dataHooks.labelIndicators,
        className: st(classes.labelIndicators, {
          inlineWithSuffix: Boolean(suffix || _this._hasCharCounter())
        })
      }, _this._renderLabel({
        trimLongText: false,
        labelSize: labelSize
      }), required && asterisk, _this._renderInfoIcon({
        labelSize: labelSize
      }));
    });

    _defineProperty(_assertThisInitialized(_this), "_renderSuffix", function () {
      var suffix = _this.props.suffix;
      return (suffix || _this._hasCharCounter()) && /*#__PURE__*/React.createElement("div", {
        "data-hook": dataHooks.suffix,
        className: classes.suffix
      }, suffix ? suffix : _this._renderCharCounter());
    });

    _defineProperty(_assertThisInitialized(_this), "_hasInlineLabel", function (label, labelPlacement) {
      return label && (labelPlacement === PLACEMENT.left || labelPlacement === PLACEMENT.right);
    });

    _defineProperty(_assertThisInitialized(_this), "_renderLabel", function (_ref3) {
      var trimLongText = _ref3.trimLongText,
          labelSize = _ref3.labelSize;
      var _this$props3 = _this.props,
          label = _this$props3.label,
          id = _this$props3.id,
          labelId = _this$props3.labelId;
      return /*#__PURE__*/React.createElement(Text, {
        size: labelSize,
        htmlFor: id,
        id: labelId,
        tagName: 'label',
        dataHook: dataHooks.label,
        ellipsis: trimLongText,
        style: {
          display: 'block'
        } // allows the label to middle vertically
        ,
        secondary: true
      }, label);
    });

    return _this;
  }

  _createClass(FormField, [{
    key: "_renderChildren",
    value: function _renderChildren() {
      var children = this.props.children;

      if (typeof children === 'function') {
        return children(this.childrenRenderPropInterface);
      }

      return children;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props4 = this.props,
          label = _this$props4.label,
          labelPlacement = _this$props4.labelPlacement,
          labelAlignment = _this$props4.labelAlignment,
          required = _this$props4.required,
          infoContent = _this$props4.infoContent,
          dataHook = _this$props4.dataHook,
          children = _this$props4.children,
          classNames = _this$props4.classNames,
          stretchContent = _this$props4.stretchContent;
      var labelSize = this.props.labelSize; // TODO: should be deprecated. Currently, no deprecation log because we are not sure when is the next major release and we don't want consumers will get lots of warnings
      // if (labelSize) {
      //   deprecationLog(
      //     `<FormField/> prop "labelSize" is deprecated and will be removed in the next major version.`,
      //   );
      // }

      var rootStyles = label ? {
        labelPlacement: labelPlacement,
        labelAlignment: labelAlignment,
        stretchContent: stretchContent,
        minLabelHeight: !children
      } : {
        stretchContent: stretchContent,
        minLabelHeight: !children
      };
      return /*#__PURE__*/React.createElement(WixStyleReactContext.Consumer, null, function (_ref4) {
        var reducedSpacingAndImprovedLayout = _ref4.reducedSpacingAndImprovedLayout;
        labelSize = reducedSpacingAndImprovedLayout && 'small' || labelSize;
        return /*#__PURE__*/React.createElement("div", {
          "data-hook": dataHook,
          className: st(classes.root, rootStyles, classNames)
        }, label && labelPlacement === PLACEMENT.top && /*#__PURE__*/React.createElement("div", {
          className: classes.label
        }, _this2._renderLabel({
          trimLongText: true,
          labelSize: labelSize
        }), required && asterisk, _this2._renderInfoIcon({
          labelSize: labelSize
        }), _this2._renderSuffix()), children && /*#__PURE__*/React.createElement("div", {
          "data-hook": dataHooks.children,
          className: st(classes.children, {
            childrenWithInlineLabel: !label || _this2._hasInlineLabel(label, labelPlacement)
          })
        }, (!label || labelPlacement !== PLACEMENT.top) && _this2._renderSuffix(), _this2._renderChildren()), !label && (required || infoContent) && _this2._renderLabelIndicators({
          labelSize: labelSize
        }), _this2._hasInlineLabel(label, labelPlacement) && _this2._renderLabelIndicators({
          labelSize: labelSize
        }));
      });
    }
  }]);

  return FormField;
}(React.Component);

_defineProperty(FormField, "displayName", 'FormField');

_defineProperty(FormField, "propTypes", {
  /** when function, it receives object with:
   * * `setCharactersLeft` - function accepts a number and will display it on top right of `FormField` component
   *
   * Note that alternatively you can also use `charCount` prop to display character count
   * instead of using the render function method.
   */

  /** Accept any kind of component as a child element. A child should be a form element like an Input, InputArea, Dropdown or RichTextArea. */
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

  /** Applies a data-hook HTML attribute that can be used in tests. */
  dataHook: PropTypes.string,

  /** Adds a string used to match text labels with FormField children items. E.g.
   *
   * ```js
   * <FormField id="myFormField" label="Hello">
   *   <Input id="myFormField"/>
   * </FormField>
   * ```
   */
  id: PropTypes.string,

  /** Displays a passed info message in a tooltip. Default value is a text string, but it can also be overridden with any other component. */
  infoContent: PropTypes.node,

  /** Allows control over the tooltip style and behaviour by passed tooltip properties. Check <Tooltip/> API for a full list. */
  infoTooltipProps: PropTypes.shape(TooltipCommonProps),

  /** Sets a field label. It’s default value is a text string, but it can be overridden with any other component. */
  label: PropTypes.node,

  /** Controls the label alignment */
  labelAlignment: PropTypes.oneOf([ALIGN.middle, ALIGN.top]),

  /** Controls the label placement */
  labelPlacement: PropTypes.oneOf([PLACEMENT.top, PLACEMENT.right, PLACEMENT.left]),

  /** Marks a field as mandatory with an asterisk (*) at the end of a label. */
  required: PropTypes.bool,

  /** Defines whether or not the content (children container) grows when there's space available. Otherwise, it only uses the necessary space. */
  stretchContent: PropTypes.bool,

  /** Adds a custom element at the end of the label row (it overrides the charCount in case it's provided). */
  suffix: PropTypes.node,

  /** Sets the maximum length for the field value. Character count is displayed in the top right corner of a component. */
  charCount: PropTypes.number,

  /** Sets the id of the label */
  labelId: PropTypes.string,

  /** @deprecated */
  labelSize: PropTypes.oneOf(['small', 'medium'])
});

_defineProperty(FormField, "defaultProps", {
  labelSize: 'medium',
  required: false,
  stretchContent: true,
  labelPlacement: PLACEMENT.top,
  labelAlignment: ALIGN.middle
});

export default FormField;