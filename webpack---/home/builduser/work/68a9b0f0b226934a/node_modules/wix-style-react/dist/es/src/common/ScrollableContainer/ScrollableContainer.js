import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["dataHook", "className", "style", "children", "onScrollAreaChanged", "onScrollChanged", "scrollThrottleWait"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { useRef, forwardRef, useCallback, useEffect } from 'react';
import PropTypes from 'prop-types';
import throttle from 'lodash/throttle';
import { getScrollAreaY } from './scrollAreaLogic';
import { extractDataAttributes } from '../../utils/extractAttributes';
var ScrollableContainer = /*#__PURE__*/forwardRef(function ScrollableContainer(_ref, ref) {
  var dataHook = _ref.dataHook,
      className = _ref.className,
      style = _ref.style,
      children = _ref.children,
      onScrollAreaChanged = _ref.onScrollAreaChanged,
      onScrollChanged = _ref.onScrollChanged,
      scrollThrottleWait = _ref.scrollThrottleWait,
      restProps = _objectWithoutProperties(_ref, _excluded);

  var elementRef = useRef(null); // In case a ref was passed from outside we should use it so allow the parent access to the dom node as well.

  var scrollContainerElement = ref || elementRef;
  var scrollAreaY = useRef('');
  var handleScrollAreaChanged = useCallback(throttle(function (_ref2) {
    var target = _ref2.target;
    var newScrollAreaY = getScrollAreaY(target);

    if (scrollAreaY.current !== newScrollAreaY) {
      scrollAreaY.current = newScrollAreaY;
      onScrollAreaChanged({
        target: target,
        area: {
          y: newScrollAreaY
        }
      });
    }
  }, scrollThrottleWait, {
    trailing: true
  }), [onScrollAreaChanged, scrollThrottleWait]);
  var handleScrollChanged = useCallback(throttle(function (e) {
    return onScrollChanged(e);
  }, scrollThrottleWait, {
    trailing: true
  }), [onScrollChanged, scrollThrottleWait]);
  useEffect(function () {
    // Registering to the scroll event only if the relevant handlers were provided
    var scrollableElement = scrollContainerElement.current;

    if (onScrollAreaChanged) {
      scrollableElement.addEventListener('scroll', handleScrollAreaChanged); // We trigger a call to this handler to expose the initial scroll area to registering consumers

      handleScrollAreaChanged({
        target: scrollableElement
      });
    }

    if (onScrollChanged) {
      scrollableElement.addEventListener('scroll', handleScrollChanged);
    }

    return function () {
      // Unregistering from relevant events on component unmount
      if (onScrollAreaChanged) {
        handleScrollAreaChanged.cancel();
        scrollableElement.removeEventListener('scroll', handleScrollAreaChanged);
      }

      if (onScrollChanged) {
        handleScrollChanged.cancel();
        scrollableElement.removeEventListener('scroll', handleScrollChanged);
      }
    };
  }, [handleScrollChanged, handleScrollAreaChanged, onScrollChanged, onScrollAreaChanged, scrollContainerElement]);

  var stl = _objectSpread(_objectSpread({
    height: 'inherit',
    width: 'inherit'
  }, style), {}, {
    overflowY: 'auto'
  });

  return /*#__PURE__*/React.createElement("div", _extends({
    "data-hook": dataHook,
    className: className,
    style: stl,
    ref: scrollContainerElement
  }, extractDataAttributes(restProps)), children);
});
ScrollableContainer.propTypes = {
  /* The wait time value the scroll event will be throttled by */
  scrollThrottleWait: PropTypes.number,

  /** A Handler for scroll area changes, will trigger only when the user scrolls to a different area of
   * the container, see signature for possible areas
   *
   * ##### Signature:
   * `function({area: {y: AreaY, x: AreaX}, target: HTMLElement}) => void`
   *
   * `AreaY`: top | middle | bottom | none
   *
   * `AreaX`: start | middle | end | none (not implemented yet)
   */
  onScrollAreaChanged: PropTypes.func,

  /** A Generic Handler for scroll changes with throttling
   * ##### Signature:
   * function({target: HTMLElement}) => void
   */
  onScrollChanged: PropTypes.func
};
ScrollableContainer.defaultProps = {
  scrollThrottleWait: 100
};
export default ScrollableContainer;