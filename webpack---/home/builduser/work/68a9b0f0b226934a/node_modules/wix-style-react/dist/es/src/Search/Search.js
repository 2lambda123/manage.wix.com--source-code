import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["defaultValue", "dataHook", "expandWidth", "highlight"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import _regeneratorRuntime from "@babel/runtime/regenerator";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import React, { Component } from 'react';
import PropTypes from 'prop-types';
import InputWithOptions from '../InputWithOptions';
import SearchIcon from 'wix-ui-icons-common/Search';
import { StringUtils } from '../utils/StringUtils';
import { st, classes } from './Search.st.css';
import Input from '../Input/Input';
import { optionValidator } from '../DropdownLayout/DropdownLayout'; // because lodash debounce is not compatible with jest timeout mocks

function debounce(fn, wait) {
  var timeout;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var context = this;
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      return fn.apply(context, args);
    }, wait);
  };
}
/**
 * Search component with suggestions based on input value listed in dropdown
 */


var Search = /*#__PURE__*/function (_Component) {
  _inherits(Search, _Component);

  var _super = _createSuper(Search);

  function Search(props) {
    var _this;

    _classCallCheck(this, Search);

    _this = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "_createDebouncedOnChange", function () {
      var _this$props = _this.props,
          debounceMs = _this$props.debounceMs,
          onChange = _this$props.onChange;
      return debounceMs > 0 ? debounce(onChange, debounceMs) : onChange;
    });

    _defineProperty(_assertThisInitialized(_this), "_getIsControlled", function () {
      return 'value' in _this.props && 'onChange' in _this.props;
    });

    _defineProperty(_assertThisInitialized(_this), "_getFilteredOptions", function () {
      var _this$props2 = _this.props,
          options = _this$props2.options,
          predicate = _this$props2.predicate;

      var searchText = _this._currentValue();

      if (!searchText || !searchText.length) {
        return options;
      }

      var filterFn = predicate || _this._stringFilter;
      return options.filter(filterFn);
    });

    _defineProperty(_assertThisInitialized(_this), "_stringFilter", function (option) {
      var searchText = _this._currentValue();

      return StringUtils.includesCaseInsensitive(option.value, searchText.trim());
    });

    _defineProperty(_assertThisInitialized(_this), "_onChange", function (e) {
      e.persist();

      _this.setState({
        inputValue: e.target.value
      }, function () {
        _this._onChangeHandler(e);
      });
    });

    _defineProperty(_assertThisInitialized(_this), "_onClear", function (event) {
      var expandable = _this.props.expandable;
      var collapsed = _this.state.collapsed;
      var stateChanges = {};

      if (!_this._getIsControlled()) {
        stateChanges.inputValue = '';
      }

      if (expandable && !collapsed && _this._currentValue === '') {
        stateChanges.collapsed = true;

        _this.searchInput.input.blur();
      }

      _this.setState(stateChanges, function () {
        _this._onClearHandler(event);
      });
    });

    _defineProperty(_assertThisInitialized(_this), "_onClearHandler", function (event) {
      var onClear = _this.props.onClear;
      if (onClear) onClear(event);
    });

    _defineProperty(_assertThisInitialized(_this), "_currentValue", function () {
      return _this.state.inputValue;
    });

    _defineProperty(_assertThisInitialized(_this), "_onFocus", function (event) {
      var onFocus = _this.props.onFocus;

      if (_this.state.collapsed && _this.props.expandable) {
        _this.setState({
          collapsed: false
        });
      }

      onFocus && onFocus(event);
    });

    _defineProperty(_assertThisInitialized(_this), "_onBlur", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(event) {
        var onBlur, value;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                onBlur = _this.props.onBlur;
                _context.t0 = onBlur;

                if (!_context.t0) {
                  _context.next = 5;
                  break;
                }

                _context.next = 5;
                return onBlur(event);

              case 5:
                if (!_this.state.collapsed && _this.props.expandable) {
                  value = _this._currentValue();

                  if (value === '') {
                    _this.setState({
                      collapsed: true
                    });
                  }
                }

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());

    _defineProperty(_assertThisInitialized(_this), "_onWrapperClick", function () {
      if (!_this.props.expandable || _this.props.expandable && _this.state.collapsed) {
        _this.searchInput.input.focus();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_onWrapperMouseDown", function (e) {
      // We need to capture mouse down and prevent it's event if the input
      // is already open
      if (_this.props.expandable && !_this.state.collapsed) {
        var value = _this._currentValue();

        if (value === '') {
          e.preventDefault();
        }
      }
    });

    var initialValue = _this._getIsControlled() ? props.value : props.defaultValue || '';
    _this._onChangeHandler = _this._createDebouncedOnChange();
    _this.state = {
      inputValue: initialValue,
      collapsed: props.expandable && !initialValue && !props.autoFocus
    };
    return _this;
  }

  _createClass(Search, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.value !== this.props.value) {
        this.setState({
          inputValue: this.props.value
        });
      }

      if (prevProps.debounceMs !== this.props.debounceMs || prevProps.onChange !== this.props.onChange) {
        this._onChangeHandler = this._createDebouncedOnChange();
      }
    }
    /**
     * Creates an onChange debounced function
     */

  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props3 = this.props,
          defaultValue = _this$props3.defaultValue,
          dataHook = _this$props3.dataHook,
          expandWidth = _this$props3.expandWidth,
          highlight = _this$props3.highlight,
          restProps = _objectWithoutProperties(_this$props3, _excluded);

      var expandable = restProps.expandable,
          size = restProps.size;
      var _this$state = this.state,
          collapsed = _this$state.collapsed,
          inputValue = _this$state.inputValue;
      var contentStyle = expandable && !collapsed ? {
        width: expandWidth
      } : undefined;
      return /*#__PURE__*/React.createElement("div", {
        "data-hook": dataHook,
        className: st(classes.root, {
          expandable: expandable,
          expanded: expandable && collapsed,
          size: size
        }),
        onClick: this._onWrapperClick,
        onMouseDown: this._onWrapperMouseDown,
        "data-expandable": expandable || null,
        "data-collapsed": expandable && collapsed || null
      }, /*#__PURE__*/React.createElement("div", {
        className: classes.content,
        style: contentStyle
      }, /*#__PURE__*/React.createElement(InputWithOptions, _extends({}, restProps, {
        value: inputValue,
        ref: function ref(r) {
          return _this2.searchInput = r;
        },
        prefix: /*#__PURE__*/React.createElement(Input.IconAffix, null, /*#__PURE__*/React.createElement(SearchIcon, null)),
        dataHook: "search-inputwithoptions",
        menuArrow: false,
        closeOnSelect: true,
        options: this._getFilteredOptions(),
        onClear: restProps.clearButton ? this._onClear : undefined,
        onChange: this._onChange,
        onFocus: this._onFocus,
        onBlur: this._onBlur,
        highlight: highlight
      }))));
    }
  }]);

  return Search;
}(Component);

_defineProperty(Search, "displayName", 'Search');

_defineProperty(Search, "propTypes", {
  /** Associate a control with the regions that it controls */
  ariaControls: PropTypes.string,

  /** Associate a region with its descriptions. Similar to aria-controls but instead associating descriptions to the region and description identifiers are separated with a space. */
  ariaDescribedby: PropTypes.string,

  /** Define a string that labels the current element in case where a text label is not visible on the screen */
  ariaLabel: PropTypes.string,

  /** Sets the value of native autocomplete attribute (consult the [HTML spec](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#attr-fe-autocomplete) for possible values)  */
  autocomplete: PropTypes.string,

  /** Focus the element on mount (standard React input autoFocus) */
  autoFocus: PropTypes.bool,

  /** Select the entire text of the element on focus (standard React input autoSelect) */
  autoSelect: PropTypes.bool,

  /** Control the border style of input */
  border: PropTypes.oneOf(['standard', 'round', 'bottomLine']),

  /** Specifies a CSS class name to be appended to the component’s root element */
  className: PropTypes.string,

  /** Displays clear button (X) on a non-empty input */
  clearButton: PropTypes.bool,

  /** Closes DropdownLayout when option is selected */
  closeOnSelect: PropTypes.bool,

  /** Render a custom input component instead of the default html input tag */
  customInput: PropTypes.node,

  /** Applies a data-hook HTML attribute that can be used in the tests */
  dataHook: PropTypes.string,

  /** Specifies the `onChange` debounce in milliseconds */
  debounceMs: PropTypes.number,

  /** Defines the initial value of an input for those who want to use this component un-controlled */
  defaultValue: PropTypes.string,

  /** Specifies whether the input should be disabled or not */
  disabled: PropTypes.bool,

  /** Restricts input editing */
  disableEditing: PropTypes.bool,

  /** Sets the offset of the dropdown from the left in pixels */
  dropdownOffsetLeft: PropTypes.string,

  /** Sets the width of the dropdown in pixels */
  dropdownWidth: PropTypes.string,

  /** Specifies whether to collapse input to search icon only. Once clicked, icon will expand to a full search input. */
  expandable: PropTypes.bool,

  /** Specifies the width of an input in an  expanded state */
  expandWidth: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** USED FOR TESTING - forces focus state on the input */
  forceFocus: PropTypes.bool,

  /** USED FOR TESTING - forces hover state on the input */
  forceHover: PropTypes.bool,

  /** Specifies whether there are more items to be loaded */
  hasMore: PropTypes.bool,

  /** Specifies whether the status suffix should be hidden */
  hideStatusSuffix: PropTypes.bool,

  /** Highlight word parts that match search criteria in bold */
  highlight: PropTypes.bool,

  /** Assigns an unique identifier for the root element */
  id: PropTypes.string,

  /** Specifies whether `<DropdownLayout/>` is in a container component. If true, some styles such as shadows, positioning and padding will be added to the component contentContainer. */
  inContainer: PropTypes.bool,

  /** Specifies whether lazy loading of the dropdown layout items is enabled */
  infiniteScroll: PropTypes.bool,

  /** Allows to render a custom input component instead of the default `<Input/>` */
  inputElement: PropTypes.element,

  /** Defines a callback function which is called on a request to render more list items */
  loadMore: PropTypes.func,

  /** Sets a maximum value of an input. Similar to HTML5 max attribute. */
  max: PropTypes.number,

  /** Sets the maximum height of the `dropdownLayout` in pixels */
  maxHeightPixels: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets the maximum number of characters that can be entered into a field */
  maxLength: PropTypes.number,

  /** Sets a minimum value of an input. Similar to HTML5 min attribute */
  min: PropTypes.number,

  /** Sets the minimum width of dropdownLayout in pixels */
  minWidthPixels: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Reference element data when a form is submitted */
  name: PropTypes.string,

  /** Specifies whether input shouldn’t have rounded corners on its left */
  noLeftBorderRadius: PropTypes.bool,

  /** Specifies whether input shouldn’t have rounded corners on its right */
  noRightBorderRadius: PropTypes.bool,

  /** Defines a standard input `onBlur` callback */
  onBlur: PropTypes.func,

  /** Defines a standard input `onChange` callback */
  onChange: PropTypes.func,

  /** Displays clear button (X) on a non-empty input and calls a callback function with no arguments */
  onClear: PropTypes.func,

  /** Defines a callback function which is called whenever the user presses the escape key */
  onClose: PropTypes.func,

  /** Defines a callback function called on `compositionstart`/`compositionend` events */
  onCompositionChange: PropTypes.func,

  /** Defines a callback handler that is called when the presses -enter- */
  onEnterPressed: PropTypes.func,

  /** Defines a callback handler that is called when the user presses -escape- */
  onEscapePressed: PropTypes.func,

  /** Defines a standard input `onFocus` callback */
  onFocus: PropTypes.func,

  /** Defines a standard input `onClick` callback */
  onInputClicked: PropTypes.func,

  /** Defines a standard input `onKeyDown` callback */
  onKeyDown: PropTypes.func,

  /** Defines a standard input `onKeyUp` callback */
  onKeyUp: PropTypes.func,

  /** Defines a callback function which is called when the user performs a submit action. Submit action triggers are:
   * "Enter", "Tab", [typing any defined delimiters], paste action.
   * `onManuallyInput(values: Array<string>): void` - the array of strings is the result of splitting the input value by the given delimiters */
  onManuallyInput: PropTypes.func,

  /** Defines a callback function which is called whenever the user enters dropdown layout with the mouse cursor */
  onMouseEnter: PropTypes.func,

  /** Defines a callback function which is called whenever the user exits from dropdown layout with a mouse cursor */
  onMouseLeave: PropTypes.func,

  /** Defines a callback function which is called whenever an option becomes focused (hovered/active). Receives the relevant option object from the original `props.options array`. */
  onOptionMarked: PropTypes.func,

  /** Defines a callback function which is called when options dropdown is hidden */
  onOptionsHide: PropTypes.func,

  /** Defines a callback function which is called when the options dropdown is shown */
  onOptionsShow: PropTypes.func,

  /** Defines a callback handler that is called when user pastes text from a clipboard (using mouse or keyboard shortcut) */
  onPaste: PropTypes.func,

  /** Defines a callback function which is called whenever user selects a different option in the list */
  onSelect: PropTypes.func,

  /** Array of objects:
   * - `id <string / number>` *required*: the id of the option, should be unique;
   * - value `<function / string / node>` *required*: can be a string, react element or a builder function;
   * - disabled `<bool>` *default value- false*: whether this option is disabled or not;
   * - linkTo `<string>`: when provided the option will be an anchor to the given value;
   * - title `<bool>`  *default value- false*  **deprecated**: please use `listItemSectionBuilder` for rendering a title;
   * - overrideStyle `<bool>` *default value- false*  **deprecated**: please use `overrideOptionStyle` for override option styles;
   * - overrideOptionStyle `<bool>` *default value- false* - when set to `true`, the option will be responsible for its own styles. No styles will be applied from the DropdownLayout itself;
   * - label `<string>`: the string displayed within an input when the option is selected. This is used when using `<DropdownLayout/>` with an `<Input/>`.
   */
  options: PropTypes.arrayOf(optionValidator),

  /** Handles container overflow */
  overflow: PropTypes.string,

  /** Sets a pattern that the typed value must match to be valid (regex) */
  pattern: PropTypes.string,

  /** Sets a placeholder message to display */
  placeholder: PropTypes.string,

  /** Allows to pass common popover props. Check `<Popover/>` API for a full list. */
  popoverProps: PropTypes.shape({
    appendTo: PropTypes.oneOf(['window', 'scrollParent', 'parent', 'viewport']),
    maxWidth: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    minWidth: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    flip: PropTypes.bool,
    fixed: PropTypes.bool,
    placement: PropTypes.oneOf(['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']),
    dynamicWidth: PropTypes.bool
  }),

  /** Defines a custom function for options filtering */
  predicate: PropTypes.func,

  /** Specifies whether input is read only */
  readOnly: PropTypes.bool,

  /** Specifies that an input must be filled out before submitting the form */
  required: PropTypes.bool,

  /** Flip the component horizontally so it’s more suitable for RTL */
  rtl: PropTypes.bool,

  /** Specifies whether the selected option will be highlighted when the dropdown is reopened */
  selectedHighlight: PropTypes.bool,

  /** Specifies selected option by its id */
  selectedId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Controls whether to show options if input is empty */
  showOptionsIfEmptyInput: PropTypes.bool,

  /** Controls the size of the input */
  size: PropTypes.oneOf(['small', 'medium', 'large']),

  /** Specify the status of a field */
  status: PropTypes.oneOf(['error', 'warning', 'loading']),

  /** Defines the message to display on status icon hover. If not given or empty there will be no tooltip. */
  statusMessage: PropTypes.node,

  /** Indicates that element can be focused and where it participates in sequential keyboard navigation */
  tabIndex: PropTypes.number,

  /** Handles text overflow behavior. It can either `clip` (default) or display `ellipsis`. */
  textOverflow: PropTypes.string,

  /** Controls the placement of a status tooltip */
  tooltipPlacement: PropTypes.string,

  /** Specifies the type of `<input>` element to display. The default type is text. */
  type: PropTypes.string,

  /** Specifies the current value of the element */
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
});

_defineProperty(Search, "defaultProps", _objectSpread(_objectSpread({}, InputWithOptions.defaultProps), {}, {
  clearButton: true,
  placeholder: 'Search',
  expandable: false,
  expandWidth: '100%',
  debounceMs: 0,
  onChange: function onChange() {},
  highlight: true,
  border: 'round'
}));

export default Search;