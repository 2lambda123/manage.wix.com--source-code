import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["customInput", "ref"],
    _excluded2 = ["className"];

var _clearButtonSizeMap;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { classes } from './Input.st.css';
import { InputContext } from './InputContext';
import { SIZES } from './constants';
import { STATUS } from '../StatusIndicator/constants.js';
import Ticker from './Ticker';
import IconAffix from './IconAffix';
import Affix from './Affix';
import Group from './Group';
import InputSuffix, { getVisibleSuffixCount } from './InputSuffix';
import deprecationLog from '../utils/deprecationLog';
var clearButtonSizeMap = (_clearButtonSizeMap = {}, _defineProperty(_clearButtonSizeMap, SIZES.small, 'small'), _defineProperty(_clearButtonSizeMap, SIZES.medium, 'medium'), _defineProperty(_clearButtonSizeMap, SIZES.large, 'medium'), _clearButtonSizeMap);

var Input = /*#__PURE__*/function (_Component) {
  _inherits(Input, _Component);

  var _super = _createSuper(Input);

  function Input(_props) {
    var _this;

    _classCallCheck(this, Input);

    _this = _super.call(this, _props);

    _defineProperty(_assertThisInitialized(_this), "_onCompositionChange", function (isComposing) {
      if (_this.props.onCompositionChange) {
        _this.props.onCompositionChange(isComposing);
      }

      _this.isComposing = isComposing;
    });

    _defineProperty(_assertThisInitialized(_this), "_extractRef", function (ref) {
      var inputRef = _this.props.inputRef;
      _this.input = ref;

      if (inputRef) {
        inputRef(ref);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_handleSuffixOnClear", function (event) {
      var focusOnClearClick = _this.props.focusOnClearClick;
      focusOnClearClick && _this.focus();

      _this.clear(event);
    });

    _defineProperty(_assertThisInitialized(_this), "_onFocus", function (event) {
      var onFocus = _this.props.onFocus;
      _this._isMounted && _this.setState({
        focus: true
      });
      onFocus && onFocus(event);

      if (_this.props.autoSelect) {
        // Set timeout is needed here since onFocus is called before react
        // gets the reference for the input (specifically when autoFocus
        // is on. So setTimeout ensures we have the ref.input needed in select)
        setTimeout(function () {
          /**
            here we trying to cover edge case with chrome forms autofill,
            after user will trigger chrome form autofill, onFocus will be called for each input,
            each input will cause this.select, select may(mostly all time) cause new onFocus,
            which will cause new this.select, ..., we have recursion which will all time randomly cause
            inputs to become focused.
            To prevent this, we check, that current input node is equal to focused node.
          */
          if (document && document.activeElement === _this.input) {
            _this.select();
          }
        }, 0);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_onBlur", function (event) {
      _this.setState({
        focus: false
      });

      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_onClick", function (event) {
      _this.props.onInputClicked && _this.props.onInputClicked(event);
    });

    _defineProperty(_assertThisInitialized(_this), "_onKeyDown", function (event) {
      if (_this.isComposing) {
        return;
      }

      var _this$props = _this.props,
          onKeyDown = _this$props.onKeyDown,
          onEnterPressed = _this$props.onEnterPressed,
          onEscapePressed = _this$props.onEscapePressed; // On key event

      onKeyDown && onKeyDown(event); // Enter

      if (event.key === 'Enter' || event.keyCode === 13) {
        onEnterPressed && onEnterPressed(event);
      } // Escape


      if (event.key === 'Escape' || event.keyCode === 27) {
        onEscapePressed && onEscapePressed(event);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_isValidInput", function (value) {
      var type = _this.props.type;

      if (type === 'number') {
        /*
         * Limit our number input to contain only:
         * - \d - digits
         * - .  - a dot
         * - ,  - a comma
         * - \- - a hyphen minus
         * - +  - a plus sign
         */
        return /^[\d.,\-+]*$/.test(value);
      }

      return true;
    });

    _defineProperty(_assertThisInitialized(_this), "_onChange", function (event) {
      var onChange = _this.props.onChange;

      if (_this._isValidInput(event.target.value)) {
        onChange && onChange(event);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_onKeyPress", function (event) {
      if (!_this._isValidInput(event.target.value + event.key)) {
        event.preventDefault();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_renderInput", function (props) {
      var CustomInputComponent = props.customInput,
          ref = props.ref,
          rest = _objectWithoutProperties(props, _excluded);

      var inputProps = _objectSpread({}, CustomInputComponent ? _objectSpread(_objectSpread({
        ref: ref
      }, rest), {}, {
        'data-hook': 'wsr-custom-input'
      }) : _objectSpread({
        ref: ref
      }, rest));

      return /*#__PURE__*/React.cloneElement(CustomInputComponent ? /*#__PURE__*/React.createElement(CustomInputComponent, null) : /*#__PURE__*/React.createElement("input", null), inputProps);
    });

    _defineProperty(_assertThisInitialized(_this), "focus", function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _this.input && _this.input.focus(options);
    });

    _defineProperty(_assertThisInitialized(_this), "blur", function () {
      _this.input && _this.input.blur();
    });

    _defineProperty(_assertThisInitialized(_this), "select", function () {
      _this.input && _this.input.select();
    });

    _defineProperty(_assertThisInitialized(_this), "clear", function (event) {
      var onClear = _this.props.onClear;

      if (!_this._isControlled) {
        _this.input.value = '';
      }

      onClear && onClear(event);
    });

    _this._isMounted = false;

    if (_props.size === 'normal') {
      deprecationLog('<Input/> - change prop size="normal" to size="medium"');
    } // TODO - deprecate (in a separate PR)
    // if (props.roundInput) {
    //   deprecationLog(
    //     '<Input/> - roundInput prop is deprecated and will be removed in next major release, please use border prop instead',
    //   );
    // }


    _this.state = {
      focus: false
    };
    return _this;
  }

  _createClass(Input, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this._isMounted = true;
      var _this$props2 = this.props,
          autoFocus = _this$props2.autoFocus,
          value = _this$props2.value;
      autoFocus && this._onFocus();
      /*
       * autoFocus doesn't automatically selects text like focus do.
       * Therefore we set the selection range, but in order to support prior implementation we set the start position as the end in order to place the cursor there.
       */

      if (autoFocus && !!value) {
        this.input.setSelectionRange(value.length, value.length);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._isMounted = false;
    }
  }, {
    key: "_isClearFeatureEnabled",
    get: function get() {
      var _this$props3 = this.props,
          onClear = _this$props3.onClear,
          clearButton = _this$props3.clearButton;
      return !!onClear || !!clearButton;
    }
  }, {
    key: "_isControlled",
    get: function get() {
      var value = this.props.value;
      return value !== undefined;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _this$props4 = this.props,
          id = _this$props4.id,
          name = _this$props4.name,
          value = _this$props4.value,
          placeholder = _this$props4.placeholder,
          menuArrow = _this$props4.menuArrow,
          defaultValue = _this$props4.defaultValue,
          tabIndex = _this$props4.tabIndex,
          autoFocus = _this$props4.autoFocus,
          onKeyUp = _this$props4.onKeyUp,
          onPaste = _this$props4.onPaste,
          disableEditing = _this$props4.disableEditing,
          readOnly = _this$props4.readOnly,
          prefix = _this$props4.prefix,
          suffix = _this$props4.suffix,
          type = _this$props4.type,
          maxLength = _this$props4.maxLength,
          textOverflow = _this$props4.textOverflow,
          disabled = _this$props4.disabled,
          status = _this$props4.status,
          statusMessage = _this$props4.statusMessage,
          tooltipPlacement = _this$props4.tooltipPlacement,
          autocomplete = _this$props4.autocomplete,
          min = _this$props4.min,
          max = _this$props4.max,
          step = _this$props4.step,
          required = _this$props4.required,
          hideStatusSuffix = _this$props4.hideStatusSuffix,
          customInput = _this$props4.customInput,
          pattern = _this$props4.pattern,
          size = _this$props4.size;

      var onIconClicked = function onIconClicked(event) {
        if (!disabled) {
          _this2.input && _this2.input.focus();

          _this2._onClick(event);
        }
      }; // this doesn't work for uncontrolled, "value" refers only to controlled input


      var isClearButtonVisible = this._isClearFeatureEnabled && !!value && !disabled;
      var showSuffix = !hideStatusSuffix && Object.values(STATUS).includes(status);
      var visibleSuffixCount = getVisibleSuffixCount({
        status: showSuffix,
        statusMessage: statusMessage,
        disabled: disabled,
        isClearButtonVisible: isClearButtonVisible,
        menuArrow: menuArrow,
        suffix: suffix
      }); // Aria Attributes

      var ariaAttribute = {};
      Object.keys(this.props).filter(function (key) {
        return key.startsWith('aria');
      }).map(function (key) {
        return ariaAttribute['aria-' + key.substr(4).toLowerCase()] = _this2.props[key];
      });
      /* eslint-disable no-unused-vars */

      var className = props.className,
          inputElementProps = _objectWithoutProperties(props, _excluded2);

      var inputElement = this._renderInput(_objectSpread(_objectSpread({
        min: min,
        max: max,
        step: step,
        'data-hook': 'wsr-input',
        style: {
          textOverflow: textOverflow
        },
        ref: this._extractRef,
        className: classes.input,
        id: id,
        name: name,
        disabled: disabled,
        defaultValue: defaultValue,
        value: value,
        onChange: this._onChange,
        onKeyPress: this._onKeyPress,
        maxLength: maxLength,
        onFocus: this._onFocus,
        onBlur: this._onBlur,
        onWheel: function onWheel() {
          // Although it's opposed to the native behavior, we decided to blur an input type="number" on wheel event in order to prevent change in value.
          if (type === 'number') _this2.blur();
        },
        onKeyDown: this._onKeyDown,
        onPaste: onPaste,
        placeholder: placeholder,
        tabIndex: tabIndex,
        autoFocus: autoFocus,
        onClick: this._onClick,
        onKeyUp: onKeyUp,
        readOnly: readOnly || disableEditing,
        type: type,
        required: required,
        autoComplete: autocomplete,
        onCompositionStart: function onCompositionStart() {
          return _this2._onCompositionChange(true);
        },
        onCompositionEnd: function onCompositionEnd() {
          return _this2._onCompositionChange(false);
        },
        customInput: customInput,
        pattern: pattern
      }, ariaAttribute), inputElementProps));

      return /*#__PURE__*/React.createElement("div", {
        className: classes.wrapper
      }, prefix && /*#__PURE__*/React.createElement(InputContext.Provider, {
        value: _objectSpread(_objectSpread({}, this.props), {}, {
          inPrefix: true
        })
      }, prefix), inputElement, /*#__PURE__*/React.createElement(InputContext.Provider, {
        value: _objectSpread(_objectSpread({}, this.props), {}, {
          inSuffix: true
        })
      }, visibleSuffixCount > 0 && /*#__PURE__*/React.createElement(InputSuffix, {
        status: showSuffix ? status : undefined,
        statusMessage: statusMessage,
        disabled: disabled,
        onIconClicked: onIconClicked,
        isClearButtonVisible: isClearButtonVisible,
        onClear: this._handleSuffixOnClear,
        clearButtonSize: clearButtonSizeMap[size],
        menuArrow: menuArrow,
        suffix: suffix,
        tooltipPlacement: tooltipPlacement
      })));
    }
  }]);

  return Input;
}(Component);

_defineProperty(Input, "Ticker", Ticker);

_defineProperty(Input, "IconAffix", IconAffix);

_defineProperty(Input, "Affix", Affix);

_defineProperty(Input, "Group", Group);

_defineProperty(Input, "StatusError", STATUS.ERROR);

_defineProperty(Input, "StatusWarning", STATUS.WARNING);

_defineProperty(Input, "StatusLoading", STATUS.LOADING);

Input.displayName = 'Input';
Input.defaultProps = {
  focusOnClearClick: true,
  autoSelect: true,
  size: 'medium',
  border: 'standard',
  roundInput: false,
  textOverflow: 'clip',
  maxLength: 524288,
  clearButton: false,
  hideStatusSuffix: false
};
Input.propTypes = {
  /** Applies a data-hook HTML attribute that can be used in the tests */
  dataHook: PropTypes.string,

  /** Specifies a CSS class name to be appended to the component’s root element */
  className: PropTypes.string,

  /** Assigns a unique identifier for the root element */
  id: PropTypes.string,

  /** Associate a control with the regions that it controls */
  ariaControls: PropTypes.string,

  /** Associate a region with its descriptions. Similar to aria-controls but instead associating descriptions to the region and description identifiers are separated with a space. */
  ariaDescribedby: PropTypes.string,

  /** Define a string that labels the current element in case where a text label is not visible on the screen */
  ariaLabel: PropTypes.string,

  /** Focus the element on mount (standard React input autoFocus) */
  autoFocus: PropTypes.bool,

  /** Select the entire text of the element on focus (standard React input autoSelect) */
  autoSelect: PropTypes.bool,

  /** Sets the value of native autocomplete attribute (check the [HTML spec](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#attr-fe-autocomplete) for possible values  */
  autocomplete: PropTypes.string,

  /** Defines the initial value of an input */
  defaultValue: PropTypes.string,

  /** Specifies whether input should be disabled or not */
  disabled: PropTypes.bool,

  /** Specify the status of a field */
  status: PropTypes.oneOf(['error', 'warning', 'loading']),

  /** Defines the message to display on status icon hover. If not given or empty there will be no tooltip. */
  statusMessage: PropTypes.node,

  /** Specifies whether status suffix should be hidden */
  hideStatusSuffix: PropTypes.bool,

  /** USED FOR TESTING - forces focus state on the input */
  forceFocus: PropTypes.bool,

  /** USED FOR TESTING - forces hover state on the input */
  forceHover: PropTypes.bool,

  /** Sets the maximum number of characters that can be inserted to a field */
  maxLength: PropTypes.number,

  /** Specifies whether input should have a dropdown menu arrow on the right side */
  menuArrow: PropTypes.bool,

  /** Displays clear button (X) on a non-empty input */
  clearButton: PropTypes.bool,

  /** Reference element data when a form is submitted */
  name: PropTypes.string,

  /** Control the border style of input */
  border: PropTypes.oneOf(['standard', 'round', 'bottomLine']),

  /**
   * When set to true, this input will be rounded
   * @deprecated
   */
  roundInput: PropTypes.bool,

  /** Specifies whether input shouldn’t have rounded corners on its left */
  noLeftBorderRadius: PropTypes.bool,

  /** Specifies whether input shouldn’t have rounded corners on its right */
  noRightBorderRadius: PropTypes.bool,

  /** Defines a standard input onBlur callback */
  onBlur: PropTypes.func,

  /** Defines a standard input onChange callback */
  onChange: PropTypes.func,

  /** Displays clear button (X) on a non-empty input and calls a callback function with no arguments */
  onClear: PropTypes.func,

  /** Defines a callback function called on compositionstart/compositionend events */
  onCompositionChange: PropTypes.func,

  /** Defines a callback handler that is called when the user presses -enter- */
  onEnterPressed: PropTypes.func,

  /** Defines a callback handler that is called when the user presses -escape- */
  onEscapePressed: PropTypes.func,

  /** Defines a standard input onFocus callback */
  onFocus: PropTypes.func,

  /** Defines a standard input onClick callback */
  onInputClicked: PropTypes.func,

  /** Defines a standard input onKeyDown callback */
  onKeyDown: PropTypes.func,

  /** Defines a standard input onKeyUp callback */
  onKeyUp: PropTypes.func,

  /** Defines a callback handler that is called when user pastes text from a clipboard (using a mouse or keyboard shortcut) */
  onPaste: PropTypes.func,

  /** Sets a placeholder message to display */
  placeholder: PropTypes.string,

  /** Pass a component you want to show as the prefix of the input, e.g., text, icon */
  prefix: PropTypes.node,

  /** Specifies whether input is read only */
  readOnly: PropTypes.bool,

  /** Restricts input editing */
  disableEditing: PropTypes.bool,

  /** Flip component horizontally so it would be more suitable to RTL */
  rtl: PropTypes.bool,

  /** Controls the size of the input */
  size: PropTypes.oneOf(['small', 'medium', 'large']),

  /** Pass a component you want to show as the suffix of the input, e.g., text, icon */
  suffix: PropTypes.node,

  /** Indicates that element can be focused and where it participates in sequential keyboard navigation */
  tabIndex: PropTypes.number,

  /** Handles text overflow behavior. It can either `clip` (default) or display `ellipsis`. */
  textOverflow: PropTypes.string,

  /** Controls placement of a status tooltip */
  tooltipPlacement: PropTypes.string,

  /** Specifies the type of `<input/>` element to display. Default is text. */
  type: PropTypes.string,

  /** Specifies the current value of the element */
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Specifies whether input is mandatory */
  required: PropTypes.bool,

  /** Sets a minimum value of an input. Similar to HTML5 min attribute. */
  min: PropTypes.number,

  /** Sets a maximum value of an input. Similar to html5 max attribute. */
  max: PropTypes.number,

  /** Specifies the interval between number values */
  step: PropTypes.number,

  /** Render a custom input instead of the default html input tag */
  customInput: PropTypes.elementType ? PropTypes.oneOfType([PropTypes.func, PropTypes.node, PropTypes.elementType]) : PropTypes.oneOfType([PropTypes.func, PropTypes.node]),

  /** Sets a pattern that typed value must match to be valid (regex) */
  pattern: PropTypes.string,

  /** Specifies whether to focus the field when clear button is clicked */
  focusOnClearClick: PropTypes.bool
};
export default Input;