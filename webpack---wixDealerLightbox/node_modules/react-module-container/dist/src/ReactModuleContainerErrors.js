'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

var ReactModuleContainerError = exports.ReactModuleContainerError = function (_extendableBuiltin2) {
  _inherits(ReactModuleContainerError, _extendableBuiltin2);

  function ReactModuleContainerError(message) {
    _classCallCheck(this, ReactModuleContainerError);

    var _this = _possibleConstructorReturn(this, (ReactModuleContainerError.__proto__ || Object.getPrototypeOf(ReactModuleContainerError)).call(this, message));

    _this.name = _this.constructor.name;

    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(_this, _this.constructor);
    } else {
      _this.stack = new Error(message).stack;
    }
    return _this;
  }

  return ReactModuleContainerError;
}(_extendableBuiltin(Error));

var UnregisteredMethodInvokedError = exports.UnregisteredMethodInvokedError = function (_ReactModuleContainer) {
  _inherits(UnregisteredMethodInvokedError, _ReactModuleContainer);

  function UnregisteredMethodInvokedError(methodName) {
    _classCallCheck(this, UnregisteredMethodInvokedError);

    var _this2 = _possibleConstructorReturn(this, (UnregisteredMethodInvokedError.__proto__ || Object.getPrototypeOf(UnregisteredMethodInvokedError)).call(this, 'ModuleRegistry.invoke ' + methodName + ' used but not yet registered'));

    _this2.name = 'UnregisteredMethodInvokedError';
    return _this2;
  }

  return UnregisteredMethodInvokedError;
}(ReactModuleContainerError);

var UnregisteredComponentUsedError = exports.UnregisteredComponentUsedError = function (_ReactModuleContainer2) {
  _inherits(UnregisteredComponentUsedError, _ReactModuleContainer2);

  function UnregisteredComponentUsedError(componentId) {
    _classCallCheck(this, UnregisteredComponentUsedError);

    var _this3 = _possibleConstructorReturn(this, (UnregisteredComponentUsedError.__proto__ || Object.getPrototypeOf(UnregisteredComponentUsedError)).call(this, 'ModuleRegistry.component ' + componentId + ' used but not yet registered'));

    _this3.name = 'UnregisteredComponentUsedError';
    return _this3;
  }

  return UnregisteredComponentUsedError;
}(ReactModuleContainerError);

var ListenerCallbackError = exports.ListenerCallbackError = function (_ReactModuleContainer3) {
  _inherits(ListenerCallbackError, _ReactModuleContainer3);

  function ListenerCallbackError(methodName, error) {
    _classCallCheck(this, ListenerCallbackError);

    var _this4 = _possibleConstructorReturn(this, (ListenerCallbackError.__proto__ || Object.getPrototypeOf(ListenerCallbackError)).call(this, 'Error in listener callback of module registry method: ' + methodName));

    _this4.name = 'ListenerCallbackError';
    _this4.stack = _this4.stack + error.stack;
    _this4.originalError = error;
    return _this4;
  }

  return ListenerCallbackError;
}(ReactModuleContainerError);

var LazyComponentLoadingError = exports.LazyComponentLoadingError = function (_ReactModuleContainer4) {
  _inherits(LazyComponentLoadingError, _ReactModuleContainer4);

  function LazyComponentLoadingError(component, error) {
    _classCallCheck(this, LazyComponentLoadingError);

    var _this5 = _possibleConstructorReturn(this, (LazyComponentLoadingError.__proto__ || Object.getPrototypeOf(LazyComponentLoadingError)).call(this, 'Error loading moduleRegistry lazy component ' + component));

    _this5.name = 'LazyComponentLoadingError';
    _this5.stack = _this5.stack + error.stack;
    _this5.originalError = error;
    return _this5;
  }

  return LazyComponentLoadingError;
}(ReactModuleContainerError);

var FileAppenderLoadError = exports.FileAppenderLoadError = function (_ReactModuleContainer5) {
  _inherits(FileAppenderLoadError, _ReactModuleContainer5);

  function FileAppenderLoadError(fileUrl) {
    _classCallCheck(this, FileAppenderLoadError);

    var _this6 = _possibleConstructorReturn(this, (FileAppenderLoadError.__proto__ || Object.getPrototypeOf(FileAppenderLoadError)).call(this, 'FilesAppender failed to load file ' + fileUrl));

    _this6.name = 'FileAppenderLoadError';
    return _this6;
  }

  return FileAppenderLoadError;
}(ReactModuleContainerError);