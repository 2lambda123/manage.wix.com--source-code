import { __assign, __spreadArrays } from "tslib";
import { getTimeFrame } from './TimeFrames/getTimeframe';
import { DaysTimeFrame } from './TimeFrames/DaysTimeFrame';
import { chunkRight } from './utils';
var QueryResult = /** @class */ (function () {
    function QueryResult(result, view, measures, dimensions) {
        this._result = result;
        this._view = view;
        this._usedMeasureKeys = measures;
        // TODO: Does it make sense for a query to have more than 1 isTimeframe dimension? If yes.. We need to think about this
        this._timeframeDimensionKeys = QueryResult.getTimeframeDimensionKeys(dimensions, this._view);
    }
    QueryResult.getTimeframeDimensionKeys = function (dimensions, view) {
        var viewDimensions = view.dimensions;
        return dimensions.filter(function (dimension) {
            return viewDimensions.find(function (viewDimension) { return viewDimension.name === dimension; }).isTimeframe;
        });
    };
    QueryResult.prototype._getToday = function () {
        return this._result[this._result.length - 1];
    };
    QueryResult.prototype._getFirstEntry = function () {
        return this._result[0];
    };
    QueryResult.prototype._getDateFromDataPoint = function (dataPoint) {
        var firstTimeframeDimension = this._timeframeDimensionKeys[0];
        return dataPoint[firstTimeframeDimension];
    };
    QueryResult.prototype.getTodayDate = function () {
        var today = this._getToday();
        return this._getDateFromDataPoint(today);
    };
    QueryResult.prototype.getFirstDate = function () {
        var firstEntry = this._getFirstEntry();
        return this._getDateFromDataPoint(firstEntry);
    };
    QueryResult.prototype._getTimeFrame = function (timeFrame) {
        return getTimeFrame(timeFrame);
    };
    QueryResult.prototype._copyData = function () {
        return __spreadArrays(this._result);
    };
    QueryResult.prototype._aggregateData = function (interval) {
        var aggregateData = null;
        var data = this._getDataFromInterval(interval);
        if (Array.isArray(data) && data.length > 0) {
            var firstDayOfPeriod = data[0];
            var lastDayOfPeriod = data[data.length - 1];
            var fromDate = firstDayOfPeriod[this._timeframeDimensionKeys[0]];
            var toDate = lastDayOfPeriod[this._timeframeDimensionKeys[0]];
            var sums_1 = {};
            var averages_1 = {};
            this._usedMeasureKeys.forEach(function (measureKey) {
                var sum = data.reduce(function (prev, next) {
                    return prev + next[measureKey];
                }, 0);
                sums_1[measureKey] = sum;
                averages_1[measureKey] = sum / data.length;
            });
            aggregateData = { fromDate: fromDate, toDate: toDate, sums: sums_1, averages: averages_1 };
        }
        return aggregateData;
    };
    QueryResult.prototype._getResultIndexFromDate = function (date) {
        var _this = this;
        return this._result.findIndex(function (dataPoint) {
            return dataPoint[_this._timeframeDimensionKeys[0]] === date;
        });
    };
    QueryResult.prototype._getDataFromInterval = function (interval) {
        var data;
        if (interval) {
            var startDate = interval.startDate, numberOfDays = interval.numberOfDays;
            var startIndex = this._getResultIndexFromDate(startDate);
            data = this._result.slice(startIndex, startIndex + numberOfDays);
        }
        return data;
    };
    QueryResult.prototype._calculatePercentageDiff = function (newNumber, oldNumber) {
        var increase = newNumber - oldNumber;
        return (increase / oldNumber) * 100;
    };
    QueryResult.prototype._getDaysBackFromTimeframe = function (timeframe) {
        var timeFrame = getTimeFrame(timeframe);
        return timeFrame.getRequiredDataLength();
    };
    QueryResult.prototype.getMeasures = function (timeframe, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var result = null;
        var _a = options.chunks, chunks = _a === void 0 ? 1 : _a, locale = options.locale;
        var oneDayTimeframe = new DaysTimeFrame(1);
        var givenTimeframe = this._getTimeFrame(timeframe);
        var todayData = oneDayTimeframe.getTimeframeData(this, { locale: locale });
        var yesterdayData = oneDayTimeframe.getPreviousTimeframeData(this, {
            locale: locale,
        });
        var currentPeriodData = givenTimeframe.getTimeframeData(this, { locale: locale });
        var previousPeriodData = givenTimeframe.getPreviousTimeframeData(this, {
            locale: locale,
        });
        var daysBack = this._getDaysBackFromTimeframe(timeframe);
        var today = this._aggregateData(todayData);
        var yesterday = this._aggregateData(yesterdayData);
        var currentPeriod = this._aggregateData(currentPeriodData);
        var previousPeriod = this._aggregateData(previousPeriodData);
        var data = this._chunkData(daysBack, currentPeriodData, chunks);
        var periodDiffPercentage = null;
        if (previousPeriod) {
            periodDiffPercentage = {};
            var sums_2 = currentPeriod.sums;
            var previousSums_1 = previousPeriod.sums;
            this._usedMeasureKeys.forEach(function (measureKey) {
                var currentValue = sums_2[measureKey];
                var previousValue = previousSums_1[measureKey];
                periodDiffPercentage[measureKey] = _this._calculatePercentageDiff(currentValue, previousValue);
            });
        }
        result = {
            data: data,
            today: today,
            yesterday: yesterday,
            currentPeriod: currentPeriod,
            previousPeriod: previousPeriod,
            periodDiffPercentage: periodDiffPercentage,
        };
        return result;
    };
    QueryResult.prototype._chunkData = function (daysBack, interval, numberOfChunks) {
        var _this = this;
        var startDate = interval.startDate, numberOfDays = interval.numberOfDays;
        var startIndex = this._getResultIndexFromDate(startDate);
        var endIndex = startIndex + numberOfDays;
        var newStartIndex = Math.max(endIndex - daysBack, 0);
        var firstDataPoint = this._result[newStartIndex];
        var dataSet = this._getDataFromInterval({
            numberOfDays: endIndex - newStartIndex,
            startDate: this._getDateFromDataPoint(firstDataPoint),
        });
        var chunks = chunkRight(dataSet, numberOfChunks);
        return chunks.map(function (chunk) {
            var _a;
            var subQueryResult = new QueryResult(chunk, _this._view, _this._usedMeasureKeys, _this._timeframeDimensionKeys);
            var firstDate = subQueryResult.getFirstDate();
            var aggregatedData = _this._aggregateData({
                startDate: firstDate,
                numberOfDays: chunk.length,
            });
            var sums = aggregatedData.sums, toDate = aggregatedData.toDate;
            var measureResult = __assign(__assign({}, sums), (_a = {}, _a[_this._timeframeDimensionKeys[0]] = toDate, _a));
            return measureResult;
        });
    };
    QueryResult.prototype.getData = function () {
        return this._result;
    };
    return QueryResult;
}());
export { QueryResult };
//# sourceMappingURL=QueryResult.js.map