import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import React from 'react';
import PropTypes from 'prop-types';
import { withFocusable } from "wix-ui-core/dist/es/src/hocs/Focusable";
import ChevronRight from 'wix-ui-icons-common/ChevronRight';
import { st, classes } from './SidebarSectionItem.st.css';
import { dataHooks } from './constants';
import Text from '../Text';
import { SidebarContext } from '../Sidebar/SidebarAPI';
import { sidebarSkins } from '../Sidebar/constants';
import { FontUpgradeContext } from '../FontUpgrade/context';
import { WixStyleReactContext } from '../WixStyleReactProvider/context';
/** An item for the section within the sidebar */

var SidebarSectionItem = /*#__PURE__*/function (_React$PureComponent) {
  _inherits(SidebarSectionItem, _React$PureComponent);

  var _super = _createSuper(SidebarSectionItem);

  function SidebarSectionItem() {
    _classCallCheck(this, SidebarSectionItem);

    return _super.apply(this, arguments);
  }

  _createClass(SidebarSectionItem, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          dataHook = _this$props.dataHook,
          children = _this$props.children,
          selected = _this$props.selected,
          disabled = _this$props.disabled,
          drillable = _this$props.drillable,
          alwaysDisplayChevron = _this$props.alwaysDisplayChevron,
          prefix = _this$props.prefix,
          suffix = _this$props.suffix,
          _onClick = _this$props.onClick,
          className = _this$props.className,
          focusableOnFocus = _this$props.focusableOnFocus,
          focusableOnBlur = _this$props.focusableOnBlur,
          itemKey = _this$props.itemKey;
      return /*#__PURE__*/React.createElement(WixStyleReactContext.Consumer, null, function (_ref) {
        var sidebarExperimentCollapsible = _ref.sidebarExperimentCollapsible;
        return /*#__PURE__*/React.createElement(SidebarContext.Consumer, null, function (context) {
          var skin = context && context.getSkin() || sidebarSkins.dark;
          return /*#__PURE__*/React.createElement("button", {
            "data-hook": dataHook,
            "data-selected": selected,
            onClick: function onClick(e) {
              if (!disabled) {
                _onClick && _onClick(e);
              }

              if (!e.defaultPrevented) {
                context && context.itemClicked(itemKey);
              }
            },
            onFocus: focusableOnFocus,
            onBlur: focusableOnBlur,
            disabled: disabled,
            type: "button",
            tabIndex: "0",
            className: st(classes.root, {
              selected: selected,
              disabled: disabled,
              prefix: Boolean(prefix),
              suffix: Boolean(suffix),
              drillable: drillable,
              skin: skin,
              alwaysDisplayChevron: alwaysDisplayChevron,
              sidebarExperimentCollapsible: sidebarExperimentCollapsible
            }, className)
          }, prefix && /*#__PURE__*/React.createElement("span", {
            "data-hook": dataHooks.prefix,
            className: classes.prefix
          }, prefix), /*#__PURE__*/React.createElement("span", {
            className: classes.textWrapper,
            "data-hook": dataHooks.title
          }, /*#__PURE__*/React.createElement(FontUpgradeContext.Consumer, null, function (_ref2) {
            var active = _ref2.active;
            return /*#__PURE__*/React.createElement(Text, {
              className: classes.text,
              size: "small",
              weight: active ? 'normal' : 'bold',
              secondary: skin === sidebarSkins.light,
              light: skin === sidebarSkins.dark,
              skin: disabled && 'disabled'
            }, children);
          })), !disabled && (suffix || drillable) && /*#__PURE__*/React.createElement("span", {
            "data-hook": dataHooks.suffix,
            className: classes.suffix
          }, suffix || /*#__PURE__*/React.createElement(ChevronRight, {
            "data-hook": dataHooks.chevronRight,
            className: classes.chevron
          })));
        });
      });
    }
  }]);

  return SidebarSectionItem;
}(React.PureComponent);

_defineProperty(SidebarSectionItem, "displayName", 'SidebarSectionItem');

_defineProperty(SidebarSectionItem, "propTypes", {
  /** Applied as data-hook HTML attribute that can be used in the tests */
  dataHook: PropTypes.string,

  /** A css class to be applied to the component's root element */
  className: PropTypes.string,

  /** Usually plain text, but could be any node */
  children: PropTypes.node.isRequired,

  /** An element to appear at the beginning of the text */
  prefix: PropTypes.node,

  /** An element to appear at the end of the text */
  suffix: PropTypes.node,

  /** Indicates whether to display the item as selected */
  selected: PropTypes.bool,

  /** Indicates whether to display the item as disabled */
  disabled: PropTypes.bool,

  /** Indicates whether to display an icon for drilling in on hover */
  drillable: PropTypes.bool,

  /** Indicates whether to display a low-opacity icon for drilling even without hover, relevant only when drillable is true */
  alwaysDisplayChevron: PropTypes.bool,

  /** A callback to be triggered on click */
  onClick: PropTypes.func,

  /** unique identifier per item, used to mark it for navigation and selection */
  itemKey: PropTypes.string
});

export default withFocusable(SidebarSectionItem);